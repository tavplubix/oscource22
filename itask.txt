В рамках решения индивидуального задания была реализована поддержка 
передачи сигналов. Для этого были реализованы функции:

int sigqueue(pid_t pid, int signo, const union sigval value);
int sigwait(const sigset_t * set, int * sig);
int sigaction(int sig, const struct sigaction * act, struct sigaction * oact);

по поведению похожие на аналогичные функции в POSIX, а также вспомогательная функция

int sigprocmask(int how, const sigset_t * set, sigset_t * oldset);

Всего поддержан 31 сигнал от SIGRESERVED (0) до SIGMAX (32), не включительно.
Поддержаны сигналы SIGKILL, SIGSTOP, SIGCONT и SIGCHLD (поведение похоже на POSIX).
Сигнал с номером 0 зарезервирован для обработчика page faults.

Поддержаны флаги SA_NOCLDSTOP, SA_SIGINFO, SA_NODEFER и SA_RESETHAND.

Каждой из из этих функций соответствует системный вызов. Для поддержки сигналов 
в структуру Env были добавлены:
 - Массив структур sigaction, описывающий как процессс должен обрабатывать 
 каждый из сигналов.
 - Кольцевая очередь сигналов, которые были отправлены процессу и ожидают обработки. 
 Элементы этой очереди содержат информацию об отправленном сигнале и его обработчике
 на момент отправки.
 - Маска сигналов, определяющая какие сигналы в настоящий момент заблокированы и 
 не должны обрабатываться.
 - Флаг, определяющий остановлен ли процесс (для поддержки SIGSTOP/SIGCONT).
 - Маска ожидаемых сигналов и указатель, по которому должен быть записан номер
 сигнала, которого процесс дождался (для поддержки sigwait).

Системный вызов sigaction обновляет соответствующий обработчик 
в массиве в Env вызывающего процесса.

Системный вызов sigqueue добабляет новый сигнал в очередь, 
либо убивает/останавливает/продолжает процесс, которому отправлен 
соответствующий сигнал. При необходимости процессу родителю также
отправляется SIGCHLD.

Системный вызов sigwait выставляет соотвествующую маску ожидаемых сигналов
и вызывает планировщик.

Непосредственно запуск обработчиков реализован в планировщике. Планировщик 
проверяет, не остановлен ли процесс и не ожидает ли он каких-то 
сигналов (check_wait_for_signal). Затем при запуске процесса проверяется, 
нет ли у него в очереди незаблокированных сигналов, для которых нужно вызвать 
обработчик (env_maybe_run_signal_handler).

Вызов обработчика сигнала (и возврат из него) реализованы аналогично 
обработчику page fault и частично переиспользуют его (call_signal_handler).
Эта функция кладёт необходимую для обработки сигнала информацию на стек процесса 
и запускает его с функции, на которую указывает env_pgfault_upcall. Для 
нормальной обработки сигналов и page faults процесс должен заранее передать
_pgfault_upcall/_signal_handler_trampoline в sys_env_set_pgfault_upcall 
(впрочем, это делает библиотека при вызове sigaction).

В зависимости от номера сигнала (0 или не 0) _pgfault_upcall вызывает библиотечную
_handle_vectored_pagefault либо _generic_signal_handler. Последняя вызывает 
пользовательский обработчик сигнала. При выходе _pgfault_upcall вызывает 
sys_sigprocmask, чтобы восстановить маску заблокированных сигналов.

Для удобства тестирования и отладки в traceopt.h добавлены макросы TEST_ITASK 
и trace_signals, которые включают отладочный вывод.

Также были добавлены поддержка запуска процессов в фоновом режиме из командного 
 интерпретатора и программа kill, что позволяет выполнять команды вроде
 $ idle &
 $ kill 0x1004 9

Были добавлены следующие тесты (можно запустить из шелла):
 - pingpongsig, аналог pingpong, использующий сигналы вместо ipc_send/ipc_recv.
 - primessig, аналог primes, использующий сигналы вместо ipc_send/ipc_recv.
 - testsig, тестирующий остальную финкциональность
 - badsig, проверяющий что от предачи мусора в системные вызовы ничего не ломается
